def T = λt λf t
def F = λt λf f
def and = λpλq dup #n p1 p2 = p; (p1 q p2)
def Z = λs λz (z)
def S = λn λs λz (s n)
def Node = λa λb λn λl (n a b)
def Leaf = λn λl l
// def Y = λf dup #f f1 f2 = f; ((λx dup #xx x1 x2 = x; (f1 (x1 x2))) (λx dup #xx x1 x2 = x; (f2 (x1 x2))))
def Y = λf dup #f f1 f2 = f; ((λx dup #xx x1 x2 = x; (f1 (x1 x2))) (λy dup #yy y1 y2 = y; (f2 (y1 y2))))
def Alloc = @alloc λn (n (λp dup #a alloc1 alloc2 = alloc; dup #p p1 p2 = p; (Node (alloc1 p1) (alloc2 p2))) Leaf)
// def Alloc = (Y λalloc λn (n (λp dup #a alloc1 alloc2 = alloc; dup #p p1 p2 = p; (Node (alloc1 p1) (alloc2 p2))) Leaf))
// def AllocF = λalloc λn (n (λp dup #a alloc1 alloc2 = alloc; dup #p p1 p2 = p; (Node (alloc1 p1) (alloc2 p2))) Leaf)
// def Alloc = (Y AllocF)
// def Alloc = λx (Y AllocF x)
def Destroy = @destroy λt (t (λaλb dup #d destroy1 destroy2 = destroy; (and (destroy1 a) (destroy2 b))) T)
// def Destroy = (Y λdestroy λt (t (λaλb dup #d destroy1 destroy2 = destroy; (and (destroy1 a) (destroy2 b))) T))
// def DestroyF = λdestroy λt (t (λaλb dup #d destroy1 destroy2 = destroy; (and (destroy1 a) (destroy2 b))) T)
// def Destroy = λx (Y DestroyF x)

// (S (S (S Z)))
// (Alloc (S (S (S Z))))
// (Alloc (S Z))
// (Alloc Z)
// (AllocF AllocF Z)
// (AllocF (AllocF AllocF) (S Z))
(Destroy (Alloc (S (S (S Z)))))
// (and T T)
